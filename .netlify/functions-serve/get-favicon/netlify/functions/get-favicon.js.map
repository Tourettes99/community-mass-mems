{
  "version": 3,
  "sources": ["../../../../Documents/community-mass-mems/community-mass-mems/netlify/functions/get-favicon.js"],
  "sourceRoot": "C:/Users/isman/AppData/Local/Temp/tmp-23272-qfNBVZ0EV1RU",
  "sourcesContent": ["const fetch = require('node-fetch');\nconst { parse } = require('url');\nconst { JSDOM } = require('jsdom');\n\nconst FALLBACK_FAVICON = 'data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 100\"><text y=\".9em\" font-size=\"90\">\uD83C\uDF10</text></svg>';\nconst FAVICON_CACHE = new Map();\nconst CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours\n\nconst corsHeaders = {\n  'Access-Control-Allow-Origin': '*',\n  'Access-Control-Allow-Headers': 'Content-Type',\n  'Access-Control-Allow-Methods': 'GET, OPTIONS'\n};\n\nexports.handler = async (event) => {\n  if (event.httpMethod === 'OPTIONS') {\n    return {\n      statusCode: 204,\n      headers: corsHeaders,\n      body: ''\n    };\n  }\n\n  try {\n    const { url } = JSON.parse(event.body);\n    if (!url) {\n      throw new Error('URL is required');\n    }\n\n    // Check cache first\n    const cachedFavicon = FAVICON_CACHE.get(url);\n    if (cachedFavicon && Date.now() - cachedFavicon.timestamp < CACHE_DURATION) {\n      return {\n        statusCode: 200,\n        headers: corsHeaders,\n        body: JSON.stringify({ favicon: cachedFavicon.data })\n      };\n    }\n\n    const parsedUrl = parse(url);\n    const baseUrl = `${parsedUrl.protocol}//${parsedUrl.host}`;\n    \n    // Try common favicon locations\n    const faviconLocations = [\n      `${baseUrl}/favicon.ico`,\n      `${baseUrl}/favicon.png`,\n      `${baseUrl}/apple-touch-icon.png`,\n      `${baseUrl}/apple-touch-icon-precomposed.png`\n    ];\n\n    // First try to fetch the page and look for favicon in meta tags\n    try {\n      const response = await fetch(url);\n      const html = await response.text();\n      const dom = new JSDOM(html);\n      const { document } = dom.window;\n\n      // Check link tags\n      const linkTags = document.querySelectorAll('link[rel*=\"icon\"]');\n      for (const link of linkTags) {\n        const href = link.getAttribute('href');\n        if (href) {\n          const faviconUrl = href.startsWith('http') ? href : `${baseUrl}${href}`;\n          faviconLocations.unshift(faviconUrl);\n        }\n      }\n    } catch (error) {\n      console.warn('Failed to parse page for favicon:', error);\n    }\n\n    // Try each location until we find a working favicon\n    for (const faviconUrl of faviconLocations) {\n      try {\n        const response = await fetch(faviconUrl);\n        if (response.ok) {\n          const contentType = response.headers.get('content-type');\n          if (contentType && contentType.includes('image')) {\n            const buffer = await response.buffer();\n            const base64 = buffer.toString('base64');\n            const favicon = `data:${contentType};base64,${base64}`;\n            \n            // Cache the result\n            FAVICON_CACHE.set(url, {\n              data: favicon,\n              timestamp: Date.now()\n            });\n            \n            return {\n              statusCode: 200,\n              headers: corsHeaders,\n              body: JSON.stringify({ favicon })\n            };\n          }\n        }\n      } catch (error) {\n        console.warn(`Failed to fetch favicon from ${faviconUrl}:`, error);\n      }\n    }\n\n    // If no favicon found, return fallback\n    return {\n      statusCode: 200,\n      headers: corsHeaders,\n      body: JSON.stringify({ favicon: FALLBACK_FAVICON })\n    };\n\n  } catch (error) {\n    console.error('Error in get-favicon:', error);\n    return {\n      statusCode: 500,\n      headers: corsHeaders,\n      body: JSON.stringify({ \n        error: 'Failed to fetch favicon',\n        favicon: FALLBACK_FAVICON \n      })\n    };\n  }\n};\n"],
  "mappings": "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",
  "names": []
}
