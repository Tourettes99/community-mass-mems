{"ast":null,"code":"import { create } from 'zustand';\nconst getValidDate = dateString => {\n  if (!dateString) return 0;\n  try {\n    const date = new Date(dateString);\n    return isNaN(date.getTime()) ? 0 : date.getTime();\n  } catch {\n    return 0;\n  }\n};\nconst useMemoryStore = create()(set => ({\n  memories: [],\n  loading: false,\n  error: null,\n  setMemories: memories => set({\n    memories: memories.sort((a, b) => {\n      var _b$metadata, _a$metadata;\n      return getValidDate((_b$metadata = b.metadata) === null || _b$metadata === void 0 ? void 0 : _b$metadata.createdAt) - getValidDate((_a$metadata = a.metadata) === null || _a$metadata === void 0 ? void 0 : _a$metadata.createdAt);\n    })\n  }),\n  addMemories: newMemories => set(state => {\n    // Create a map of existing memories by ID for quick lookup\n    const existingMemories = new Map(state.memories.map(m => [m.id || m._id, m]));\n\n    // Only add memories that don't already exist\n    const uniqueNewMemories = newMemories.filter(m => !existingMemories.has(m.id || m._id));\n    return {\n      memories: [...uniqueNewMemories, ...state.memories].sort((a, b) => {\n        var _b$metadata2, _a$metadata2;\n        return getValidDate((_b$metadata2 = b.metadata) === null || _b$metadata2 === void 0 ? void 0 : _b$metadata2.createdAt) - getValidDate((_a$metadata2 = a.metadata) === null || _a$metadata2 === void 0 ? void 0 : _a$metadata2.createdAt);\n      })\n    };\n  }),\n  updateMemory: updatedMemory => set(state => {\n    // Check if memory already exists\n    const memoryExists = state.memories.some(m => m.id === updatedMemory.id || m._id === updatedMemory._id);\n    if (!memoryExists) {\n      return state;\n    }\n    const newMemories = state.memories.map(memory => memory.id === updatedMemory.id || memory._id === updatedMemory._id ? {\n      ...memory,\n      ...updatedMemory\n    } : memory);\n    return {\n      memories: newMemories.sort((a, b) => {\n        var _b$metadata3, _a$metadata3;\n        return getValidDate((_b$metadata3 = b.metadata) === null || _b$metadata3 === void 0 ? void 0 : _b$metadata3.createdAt) - getValidDate((_a$metadata3 = a.metadata) === null || _a$metadata3 === void 0 ? void 0 : _a$metadata3.createdAt);\n      })\n    };\n  }),\n  setLoading: loading => set({\n    loading\n  }),\n  setError: error => set({\n    error\n  })\n}));\nexport default useMemoryStore;","map":{"version":3,"names":["create","getValidDate","dateString","date","Date","isNaN","getTime","useMemoryStore","set","memories","loading","error","setMemories","sort","a","b","_b$metadata","_a$metadata","metadata","createdAt","addMemories","newMemories","state","existingMemories","Map","map","m","id","_id","uniqueNewMemories","filter","has","_b$metadata2","_a$metadata2","updateMemory","updatedMemory","memoryExists","some","memory","_b$metadata3","_a$metadata3","setLoading","setError"],"sources":["c:/Users/isman/Documents/community-mass-mems/community-mass-mems/src/stores/memoryStore.ts"],"sourcesContent":["import { create } from 'zustand';\nimport { Memory } from '../types/Memory';\n\ninterface MemoryStore {\n  memories: Memory[];\n  loading: boolean;\n  error: string | null;\n  setMemories: (memories: Memory[]) => void;\n  addMemories: (newMemories: Memory[]) => void;\n  updateMemory: (updatedMemory: Memory) => void;\n  setLoading: (loading: boolean) => void;\n  setError: (error: string | null) => void;\n}\n\nconst getValidDate = (dateString?: string): number => {\n  if (!dateString) return 0;\n  try {\n    const date = new Date(dateString);\n    return isNaN(date.getTime()) ? 0 : date.getTime();\n  } catch {\n    return 0;\n  }\n};\n\nconst useMemoryStore = create<MemoryStore>()((set) => ({\n  memories: [],\n  loading: false,\n  error: null,\n  \n  setMemories: (memories) => set({ \n    memories: memories.sort((a, b) => \n      getValidDate(b.metadata?.createdAt) - getValidDate(a.metadata?.createdAt)\n    )\n  }),\n  \n  addMemories: (newMemories) => set((state) => {\n    // Create a map of existing memories by ID for quick lookup\n    const existingMemories = new Map(\n      state.memories.map(m => [(m.id || m._id), m])\n    );\n\n    // Only add memories that don't already exist\n    const uniqueNewMemories = newMemories.filter(\n      m => !existingMemories.has(m.id || m._id)\n    );\n\n    return {\n      memories: [...uniqueNewMemories, ...state.memories].sort((a, b) => \n        getValidDate(b.metadata?.createdAt) - getValidDate(a.metadata?.createdAt)\n      )\n    };\n  }),\n  \n  updateMemory: (updatedMemory) => set((state) => {\n    // Check if memory already exists\n    const memoryExists = state.memories.some(\n      m => m.id === updatedMemory.id || m._id === updatedMemory._id\n    );\n\n    if (!memoryExists) {\n      return state;\n    }\n\n    const newMemories = state.memories.map((memory) => \n      (memory.id === updatedMemory.id || memory._id === updatedMemory._id) \n        ? { ...memory, ...updatedMemory }\n        : memory\n    );\n    \n    return {\n      memories: newMemories.sort((a, b) => \n        getValidDate(b.metadata?.createdAt) - getValidDate(a.metadata?.createdAt)\n      )\n    };\n  }),\n\n  setLoading: (loading) => set({ loading }),\n  setError: (error) => set({ error })\n}));\n\nexport default useMemoryStore;\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,SAAS;AAchC,MAAMC,YAAY,GAAIC,UAAmB,IAAa;EACpD,IAAI,CAACA,UAAU,EAAE,OAAO,CAAC;EACzB,IAAI;IACF,MAAMC,IAAI,GAAG,IAAIC,IAAI,CAACF,UAAU,CAAC;IACjC,OAAOG,KAAK,CAACF,IAAI,CAACG,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,GAAGH,IAAI,CAACG,OAAO,CAAC,CAAC;EACnD,CAAC,CAAC,MAAM;IACN,OAAO,CAAC;EACV;AACF,CAAC;AAED,MAAMC,cAAc,GAAGP,MAAM,CAAc,CAAC,CAAEQ,GAAG,KAAM;EACrDC,QAAQ,EAAE,EAAE;EACZC,OAAO,EAAE,KAAK;EACdC,KAAK,EAAE,IAAI;EAEXC,WAAW,EAAGH,QAAQ,IAAKD,GAAG,CAAC;IAC7BC,QAAQ,EAAEA,QAAQ,CAACI,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC;MAAA,IAAAC,WAAA,EAAAC,WAAA;MAAA,OAC3BhB,YAAY,EAAAe,WAAA,GAACD,CAAC,CAACG,QAAQ,cAAAF,WAAA,uBAAVA,WAAA,CAAYG,SAAS,CAAC,GAAGlB,YAAY,EAAAgB,WAAA,GAACH,CAAC,CAACI,QAAQ,cAAAD,WAAA,uBAAVA,WAAA,CAAYE,SAAS,CAAC;IAAA,CAC3E;EACF,CAAC,CAAC;EAEFC,WAAW,EAAGC,WAAW,IAAKb,GAAG,CAAEc,KAAK,IAAK;IAC3C;IACA,MAAMC,gBAAgB,GAAG,IAAIC,GAAG,CAC9BF,KAAK,CAACb,QAAQ,CAACgB,GAAG,CAACC,CAAC,IAAI,CAAEA,CAAC,CAACC,EAAE,IAAID,CAAC,CAACE,GAAG,EAAGF,CAAC,CAAC,CAC9C,CAAC;;IAED;IACA,MAAMG,iBAAiB,GAAGR,WAAW,CAACS,MAAM,CAC1CJ,CAAC,IAAI,CAACH,gBAAgB,CAACQ,GAAG,CAACL,CAAC,CAACC,EAAE,IAAID,CAAC,CAACE,GAAG,CAC1C,CAAC;IAED,OAAO;MACLnB,QAAQ,EAAE,CAAC,GAAGoB,iBAAiB,EAAE,GAAGP,KAAK,CAACb,QAAQ,CAAC,CAACI,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC;QAAA,IAAAiB,YAAA,EAAAC,YAAA;QAAA,OAC5DhC,YAAY,EAAA+B,YAAA,GAACjB,CAAC,CAACG,QAAQ,cAAAc,YAAA,uBAAVA,YAAA,CAAYb,SAAS,CAAC,GAAGlB,YAAY,EAAAgC,YAAA,GAACnB,CAAC,CAACI,QAAQ,cAAAe,YAAA,uBAAVA,YAAA,CAAYd,SAAS,CAAC;MAAA,CAC3E;IACF,CAAC;EACH,CAAC,CAAC;EAEFe,YAAY,EAAGC,aAAa,IAAK3B,GAAG,CAAEc,KAAK,IAAK;IAC9C;IACA,MAAMc,YAAY,GAAGd,KAAK,CAACb,QAAQ,CAAC4B,IAAI,CACtCX,CAAC,IAAIA,CAAC,CAACC,EAAE,KAAKQ,aAAa,CAACR,EAAE,IAAID,CAAC,CAACE,GAAG,KAAKO,aAAa,CAACP,GAC5D,CAAC;IAED,IAAI,CAACQ,YAAY,EAAE;MACjB,OAAOd,KAAK;IACd;IAEA,MAAMD,WAAW,GAAGC,KAAK,CAACb,QAAQ,CAACgB,GAAG,CAAEa,MAAM,IAC3CA,MAAM,CAACX,EAAE,KAAKQ,aAAa,CAACR,EAAE,IAAIW,MAAM,CAACV,GAAG,KAAKO,aAAa,CAACP,GAAG,GAC/D;MAAE,GAAGU,MAAM;MAAE,GAAGH;IAAc,CAAC,GAC/BG,MACN,CAAC;IAED,OAAO;MACL7B,QAAQ,EAAEY,WAAW,CAACR,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC;QAAA,IAAAwB,YAAA,EAAAC,YAAA;QAAA,OAC9BvC,YAAY,EAAAsC,YAAA,GAACxB,CAAC,CAACG,QAAQ,cAAAqB,YAAA,uBAAVA,YAAA,CAAYpB,SAAS,CAAC,GAAGlB,YAAY,EAAAuC,YAAA,GAAC1B,CAAC,CAACI,QAAQ,cAAAsB,YAAA,uBAAVA,YAAA,CAAYrB,SAAS,CAAC;MAAA,CAC3E;IACF,CAAC;EACH,CAAC,CAAC;EAEFsB,UAAU,EAAG/B,OAAO,IAAKF,GAAG,CAAC;IAAEE;EAAQ,CAAC,CAAC;EACzCgC,QAAQ,EAAG/B,KAAK,IAAKH,GAAG,CAAC;IAAEG;EAAM,CAAC;AACpC,CAAC,CAAC,CAAC;AAEH,eAAeJ,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}